using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using YamlDotNet.RepresentationModel;
using datamodel.utils;

namespace datamodel.schema {
    // Read the file generated by the Ruby metadata extractor and convert it into an internal representation
    internal class YamlSchemaParser {

        #region Parse Tables
        public List<Table> ParseTables(YamlSequenceNode yamlEntities) {
            List<Table> tables = new List<Table>();

            foreach (YamlMappingNode tableData in yamlEntities) {
                Table table = new Table() {
                    ClassName = YamlUtils.GetString(tableData, "entity_name"),
                    SuperClassName = YamlUtils.GetString(tableData, "superclass"),
                    DbName = YamlUtils.GetString(tableData, "table_name"),
                };

                // Columns
                YamlSequenceNode yamlColumns = YamlUtils.GetSequence(tableData, "columns");
                if (yamlColumns == null)
                    continue;           // No columns means ??? - things like 'session' whatever that is

                List<Column> columns = new List<Column>();

                foreach (YamlMappingNode columnData in yamlColumns) {
                    Column column = null;
                    string dbName = YamlUtils.GetString(columnData, "name");

                    if (dbName.EndsWith(FkColumn.ID_SUFFIX))
                        column = new FkColumn(table);
                    else
                        column = new Column(table);

                    column.DbName = dbName;
                    column.DbTypeString = YamlUtils.GetString(columnData, "type");
                    column.DbType = ToDbType(YamlUtils.GetString(columnData, "type"));
                    column.IsMandatory = YamlUtils.GetBoolean(columnData, "mandatory");

                    columns.Add(column);
                }

                table.AllColumns = columns.OrderBy(x => x.HumanName).ToList();

                if (table.ClassName != null && table.DbName != null)
                    tables.Add(table);
            }

            return tables;
        }

        private DataType ToDbType(string typeString) {
            switch (typeString) {
                case "integer": return DataType.Integer;
                // TODO - currently not used
                default: return DataType.Inet;
            }
        }
        #endregion

        #region Parse Relationships (Ruby Terminology) or Associations (Generic Terminology)
        public List<Association> ParseAssociations(YamlSequenceNode yamlRelationships) {
            List<Association> associations = new List<Association>();

            foreach (YamlMappingNode data in yamlRelationships) {
                Association association = new Association() {
                    Source = YamlUtils.GetString(data, "source"),
                    Destination = YamlUtils.GetString(data, "destination"),
                    Indirect = YamlUtils.GetBoolean(data, "indirect"),
                    Mutual = YamlUtils.GetBoolean(data, "mutual"),
                    Recursive = YamlUtils.GetBoolean(data, "recursive"),
                    Cardinality = Enum.Parse<Cardinality>(YamlUtils.GetString(data, "cardinality")),
                    SourceOptional = YamlUtils.GetBoolean(data, "source_optional"),
                    DestinationOptional = YamlUtils.GetBoolean(data, "destination_optional"),
                };

                // Ruby Associations - They are parsed but discarded until we find a use for them
                // Perhaps Roles???
                YamlSequenceNode rubyAssociations = YamlUtils.GetSequence(data, "associations");
                foreach (YamlMappingNode assocData in rubyAssociations)
                    RubyAssociation.Parse(assocData);

                associations.Add(association);
            }

            return associations;
        }
        #endregion
    }

    class RubyAssociation {
        internal enum AssociationKind {
            BelongsTo,
            HasOne,
            HasMany,
            HasAndBelongsToMany,
            Through,
        }

        internal AssociationKind Kind;
        internal string Name;
        internal Options Options;
        internal string Class;
        internal string PluralName;
        internal string Type;
        internal string ForeignType;

        internal static RubyAssociation Parse(YamlMappingNode assocData) {
            return new RubyAssociation() {
                Kind = ParseKind(YamlUtils.GetString(assocData, "kind")),
                Name = YamlUtils.GetString(assocData, "name"),
                Options = Options.Parse(YamlUtils.GetString(assocData, "options")),
                Class = YamlUtils.GetString(assocData, "klass"),
                PluralName = YamlUtils.GetString(assocData, "plural_name"),
                Type = YamlUtils.GetString(assocData, "type"),
                ForeignType = YamlUtils.GetString(assocData, "foreign_type"),
            };
        }

        private static AssociationKind ParseKind(string kind) {
            switch (kind) {
                case "ActiveRecord::Reflection::BelongsToReflection": return AssociationKind.BelongsTo;
                case "ActiveRecord::Reflection::HasOneReflection": return AssociationKind.HasOne;
                case "ActiveRecord::Reflection::HasManyReflection": return AssociationKind.HasMany;
                case "ActiveRecord::Reflection::HasAndBelongsToManyReflection": return AssociationKind.HasAndBelongsToMany;
                case "ActiveRecord::Reflection::ThroughReflection": return AssociationKind.Through;

                default:
                    throw new Exception("Unexpected kind: " + kind);
            }
        }
    }

    class Options {
        internal bool Polymorphic;
        internal string ClassName;
        internal string As;
        internal bool Destroy;
        internal string InverseOf;
        internal string Through;
        internal string ForeignKey;
        internal string Source;

        internal static Options Parse(string options) {
            options = options.Trim();
            options = options.Substring(1, options.Length - 2);
            if (options == "")
                return new Options();

            string[] pieces = options.Split(",").Select(x => x.Trim()).ToArray();

            Dictionary<string, string> dict = new Dictionary<string, string>();
            foreach (string piece in pieces) {
                string[] keyValue = piece.Split("=>");
                dict[keyValue[0]] = keyValue[1];
            }

            return new Options() {
                Polymorphic = GetBoolean(dict, ":polymorphic", false),
                ClassName = GetString(dict, ":class_name"),
                As = GetString(dict, ":as"),
                Destroy = GetString(dict, ":dependent") == ":destroy",
                InverseOf = GetString(dict, ":inverse_of"),
                Through = GetString(dict, ":through"),
                ForeignKey = GetString(dict, ":foreign_key"),
                Source = GetString(dict, ":source"),
            };
        }

        private static string GetString(Dictionary<string, string> dict, string key) {
            if (!dict.TryGetValue(key, out string value))
                return null;
            return value;
        }

        private static bool GetBoolean(Dictionary<string, string> dict, string key, bool defaultValue) {
            string value = GetString(dict, key);
            if (value == null)
                return defaultValue;
            return bool.Parse(value);
        }
    }
}