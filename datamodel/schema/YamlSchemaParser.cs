using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using YamlDotNet.RepresentationModel;
using datamodel.utils;

namespace datamodel.schema {
    // Read the file generated by the Ruby metadata extractor and convert it into an internal representation
    internal class YamlSchemaParser {

        #region Parse Tables
        public List<Table> ParseTables(YamlSequenceNode yamlEntities) {
            List<Table> tables = new List<Table>();

            foreach (YamlMappingNode tableData in yamlEntities) {
                Table table = new Table() {
                    ClassName = YamlUtils.GetString(tableData, "entity_name"),
                    SuperClassName = YamlUtils.GetString(tableData, "superclass"),
                    IsSpecialized = YamlUtils.GetBoolean(tableData, "specialized"),
                    DbName = YamlUtils.GetString(tableData, "table_name"),
                };

                // Columns
                YamlSequenceNode yamlColumns = YamlUtils.GetSequence(tableData, "columns");
                if (yamlColumns == null)
                    continue;           // No columns means ??? - things like 'session' whatever that is

                List<Column> columns = new List<Column>();
                IEnumerable<string> allColumns = yamlColumns.Select(x => YamlUtils.GetString((YamlMappingNode)x, "name"));

                foreach (YamlMappingNode columnData in yamlColumns)
                    columns.Add(new Column(table) {
                        DbName = YamlUtils.GetString(columnData, "name"),
                        DbTypeString = YamlUtils.GetString(columnData, "type"),
                        DbType = ToDbType(YamlUtils.GetString(columnData, "type")),
                        IsNull = YamlUtils.GetBoolean(columnData, "null"),
                        Validations = YamlUtils.GetString(columnData, "validations")
                            .Split(",").Select(x => x.Trim()).ToArray(),
                    });

                table.AllColumns = columns.OrderBy(x => x.HumanName).ToList();

                bool isDerived = table.SuperClassName != "ApplicationRecord" && table.SuperClassName != "ActiveRecord::Base";
                if (isDerived)
                    Console.WriteLine("Warning: skipping table {0} because it is derived from {1}", table.ClassName, table.SuperClassName);
                else
                    tables.Add(table);
            }

            return tables;
        }

        private DataType ToDbType(string typeString) {
            return EnumUtils.TryParse<DataType>(typeString, DataType.Other);
        }
        #endregion

        #region Parse Associations
        public List<RailsAssociation> ParseAssociations(YamlSequenceNode yamlRelationships) {
            List<RailsAssociation> associations = new List<RailsAssociation>();

            foreach (YamlMappingNode data in yamlRelationships)
                associations.Add(ParseRailsAssociation(data));

            return associations;
        }

        private static RailsAssociation ParseRailsAssociation(YamlMappingNode assocData) {
            return new RailsAssociation() {
                Kind = ParseKind(YamlUtils.GetString(assocData, "kind")),
                Name = YamlUtils.GetString(assocData, "name"),
                ActiveRecord = YamlUtils.GetString(assocData, "active_record"),
                ClassName = YamlUtils.GetString(assocData, "class_name"),
                Klass = YamlUtils.GetString(assocData, "klass"),
                ForeignKey = YamlUtils.GetString(assocData, "foreign_key"),
                ForeignType = YamlUtils.GetString(assocData, "foreign_type"),
                InverseOf = YamlUtils.GetString(assocData, "inverse_of"),
                PluralName = YamlUtils.GetString(assocData, "plural_name"),
                Type = YamlUtils.GetString(assocData, "type"),
                Options = ParseOptions(YamlUtils.GetString(assocData, "options")),
            };
        }

        private static AssociationKind ParseKind(string kind) {
            switch (kind) {
                case "BelongsToReflection": return AssociationKind.BelongsTo;
                case "HasOneReflection": return AssociationKind.HasOne;
                case "HasManyReflection": return AssociationKind.HasMany;
                case "HasAndBelongsToManyReflection": return AssociationKind.HasAndBelongsToMany;
                case "ThroughReflection": return AssociationKind.Through;

                default:
                    throw new Exception("Unexpected kind: " + kind);
            }
        }

        internal static Options ParseOptions(string options) {
            options = options.Trim();
            options = options.Substring(1, options.Length - 2);
            if (options == "")
                return new Options();

            string[] pieces = options.Split(",").Select(x => x.Trim()).ToArray();

            Dictionary<string, string> dict = new Dictionary<string, string>();
            foreach (string piece in pieces) {
                string[] keyValue = piece.Split("=>");
                dict[keyValue[0]] = keyValue[1];
            }

            return new Options() {
                Polymorphic = GetBoolean(dict, ":polymorphic", false),
                ClassName = GetString(dict, ":class_name"),
                As = GetString(dict, ":as"),
                Destroy = GetString(dict, ":dependent") == ":destroy",
                InverseOf = GetString(dict, ":inverse_of"),
                Through = GetString(dict, ":through"),
                ForeignKey = GetString(dict, ":foreign_key"),
                Source = GetString(dict, ":source"),
            };
        }

        private static string GetString(Dictionary<string, string> dict, string key) {
            if (!dict.TryGetValue(key, out string value))
                return null;
            return value;
        }

        private static bool GetBoolean(Dictionary<string, string> dict, string key, bool defaultValue) {
            string value = GetString(dict, key);
            if (value == null)
                return defaultValue;
            return bool.Parse(value);
        }

        #endregion
    }
}