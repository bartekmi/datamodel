using System;
using System.Collections.Generic;
using System.Linq;

using YamlDotNet.RepresentationModel;

using datamodel.utils;

namespace datamodel.schema {
    // Read the file generated by the Ruby metadata extractor and convert it into an internal representation
    internal class YamlSchemaParser {

        private YamlMappingNode _root;

        #region Constructor
        internal YamlSchemaParser() {
            _root = (YamlMappingNode)YamlUtils.ReadYaml(Env.SCHEMA_FILE).RootNode;
        }
        #endregion

        #region Parse Models
        public List<Model> ParseModels() {
            YamlSequenceNode yamlEntities = YamlUtils.GetSequence(_root, "entities");
            List<Model> models = new List<Model>();

            foreach (YamlMappingNode tableData in yamlEntities) {
                Model model = new Model() {
                    ClassName = YamlUtils.GetString(tableData, "entity_name"),
                    SuperClassName = YamlUtils.GetString(tableData, "superclass"),
                    IsAbstract = YamlUtils.GetBoolean(tableData, "is_abstract"),
                    DbName = YamlUtils.GetString(tableData, "table_name"),
                };

                YamlSequenceNode yamlColumns = YamlUtils.GetSequence(tableData, "columns");
                model.AllColumns = ParseColumns(model, yamlColumns);

                YamlSequenceNode yamlEnums = YamlUtils.GetSequence(tableData, "enums");
                ParseEnums(model, yamlEnums);

                models.Add(model);
            }

            return models;
        }

        private List<Column> ParseColumns(Model model, YamlSequenceNode yamlColumns) {
            List<Column> columns = new List<Column>();

            if (yamlColumns != null)
                foreach (YamlMappingNode columnData in yamlColumns)
                    columns.Add(new Column(model) {
                        DbName = YamlUtils.GetString(columnData, "name"),
                        DbTypeString = YamlUtils.GetString(columnData, "type"),
                        DbType = ToDbType(YamlUtils.GetString(columnData, "type")),
                        IsNull = YamlUtils.GetBoolean(columnData, "null"),
                        Validations = CommaListToArray(YamlUtils.GetString(columnData, "validations")),
                    });

            return columns.OrderBy(x => x.HumanName).ToList();
        }

        private void ParseEnums(Model model, YamlSequenceNode yamlEnums) {
            if (yamlEnums != null)
                foreach (YamlMappingNode enumData in yamlEnums) {
                    string columnName = YamlUtils.GetString(enumData, "name");
                    Column column = model.FindColumn(columnName);
                    if (column == null) {
                        Error.Log(string.Format("No column for enum {0} in model {1}", columnName, model.ClassName));
                    } else {
                        YamlSequenceNode yamlValues = YamlUtils.GetSequence(enumData, "values");
                        Enum _enum = new Enum();
                        foreach (YamlMappingNode valueData in yamlValues) {
                            _enum.Add(
                                YamlUtils.GetInt(valueData, "number"),
                                YamlUtils.GetString(valueData, "string")
                            );
                        }
                        column.Enum = _enum;
                        column.DbType = DataType.Enum;
                    }
                }
        }

        private DataType ToDbType(string typeString) {
            return EnumUtils.TryParse<DataType>(typeString, DataType.Other);
        }
        #endregion

        #region Parse Associations
        public List<RailsAssociation> ParseAssociations() {
            YamlSequenceNode yamlRelationships = YamlUtils.GetSequence(_root, "associations");
            List<RailsAssociation> associations = new List<RailsAssociation>();

            foreach (YamlMappingNode data in yamlRelationships)
                associations.Add(ParseRailsAssociation(data));

            return associations;
        }

        private static RailsAssociation ParseRailsAssociation(YamlMappingNode assocData) {
            return new RailsAssociation() {
                Kind = ParseKind(YamlUtils.GetString(assocData, "kind")),
                Name = YamlUtils.GetString(assocData, "name"),
                OwningModel = YamlUtils.GetString(assocData, "active_record"),
                OtherModel = YamlUtils.GetString(assocData, "klass"),
                ClassName = YamlUtils.GetString(assocData, "class_name"),
                ForeignKey = YamlUtils.GetString(assocData, "foreign_key"),
                ForeignType = YamlUtils.GetString(assocData, "foreign_type"),
                InverseOf = YamlUtils.GetString(assocData, "inverse_of"),
                PluralName = YamlUtils.GetString(assocData, "plural_name"),
                Type = YamlUtils.GetString(assocData, "type"),
                Options = ParseOptions(YamlUtils.GetString(assocData, "options")),
                Validations = CommaListToArray(YamlUtils.GetString(assocData, "validations")),
            };
        }

        private static AssociationKind ParseKind(string kind) {
            switch (kind) {
                case "BelongsToReflection": return AssociationKind.BelongsTo;
                case "HasOneReflection": return AssociationKind.HasOne;
                case "HasManyReflection": return AssociationKind.HasMany;
                case "HasAndBelongsToManyReflection": return AssociationKind.HasAndBelongsToMany;
                case "ThroughReflection": return AssociationKind.Through;

                default:
                    throw new Exception("Unexpected kind: " + kind);
            }
        }

        internal static Options ParseOptions(string options) {
            if (options == null)
                return new Options();

            options = options.Trim();
            options = options.Substring(1, options.Length - 2);
            if (options == "")
                return new Options();

            string[] pieces = options.Split(",").Select(x => x.Trim()).ToArray();

            Dictionary<string, string> dict = new Dictionary<string, string>();
            foreach (string piece in pieces) {
                string[] keyValue = piece.Split("=>");

                // We don't yet parse anonymous_class generated for HABTM
                if (keyValue.Length == 2)
                    dict[keyValue[0]] = keyValue[1];
            }

            return new Options() {
                Polymorphic = GetBoolean(dict, ":polymorphic", false),
                ClassName = GetString(dict, ":class_name"),
                As = GetString(dict, ":as", true),
                Destroy = GetString(dict, ":dependent") == ":destroy",
                InverseOf = GetString(dict, ":inverse_of"),
                Through = GetString(dict, ":through"),
                ForeignKey = GetString(dict, ":foreign_key"),
                Source = GetString(dict, ":source"),
            };
        }

        private static string GetString(Dictionary<string, string> dict, string key, bool stripColons = false) {
            if (!dict.TryGetValue(key, out string value))
                return null;

            if (stripColons)
                value = value.Replace(":", "");

            value = value.Replace("\"", "");

            return value;
        }

        private static bool GetBoolean(Dictionary<string, string> dict, string key, bool defaultValue) {
            string value = GetString(dict, key);
            if (value == null)
                return defaultValue;
            return bool.Parse(value);
        }

        #endregion

        #region Utils

        private static string[] CommaListToArray(string commaList) {
            if (commaList == null)
                return new String[0];
            return commaList.Split(",").Select(x => x.Trim()).ToArray();
        }
        #endregion
    }
}